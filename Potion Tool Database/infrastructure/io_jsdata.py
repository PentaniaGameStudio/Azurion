"""
Lecture/écriture de data.js (ORIGIN_TREE + BOOKS).
Parser minimaliste basé sur extraction de littéraux et ast.literal_eval.

- Supporte "const/let/var ORIGIN_TREE = {...};" avec guillemets simples ou doubles.
- Supporte "BOOKS = ['A','B']" ou "BOOKS = [{title:'A'}, ...]" (converti en liste de strings).
- Écrit en ES module standard avec JSON.stringify-like (via json.dumps).
"""

from __future__ import annotations

import ast
import json
import os
import re
from typing import Any, List, Tuple

from domain.errors import RepositoryError
from .paths import ensure_parent_dir, atomic_write_text, make_backup


# ---------- Public API ----------

def read_data_js(path: str) -> Tuple[dict, List[str]]:
    """
    Retourne (origin_tree: dict, books: list[str]).
    Si le fichier est manquant, retourne ({}, []).
    """
    try:
        with open(path, "r", encoding="utf-8") as f:
            content = f.read()
    except FileNotFoundError:
        return ({}, [])

    try:
        tree_literal = _extract_literal_after_var(content, "ORIGIN_TREE", brace="{", closing="}")
        books_literal = _extract_literal_after_var(content, "BOOKS", brace="[", closing="]")

        origin_tree = _safe_eval_dict(tree_literal) if tree_literal else {}
        books_raw = _safe_eval_any(books_literal) if books_literal else []
        books = _normalize_books(books_raw)
        return (origin_tree, books)
    except Exception as e:
        raise RepositoryError(f"Lecture data.js échouée: {e}") from e


def write_data_js(path: str, *, origin_tree: dict, books: List[str]) -> None:
    """
    Écrit le fichier au format ES module, en remplaçant complètement le contenu.
    """
    try:
        ensure_parent_dir(path)
        make_backup(path)
        js_tree = json.dumps(origin_tree or {}, ensure_ascii=False, indent=2, sort_keys=True)
        js_books = json.dumps(list(books or []), ensure_ascii=False, indent=2)
        header = "// Auto-generated by Potion DB Tool\n"
        body = (
            f"export const ORIGIN_TREE = {js_tree};\n\n"
            f"export const BOOKS = {js_books};\n"
        )
        atomic_write_text(path, header + body)
    except Exception as e:
        raise RepositoryError(f"Écriture data.js échouée: {e}") from e


# ---------- Internals ----------

def _extract_literal_after_var(src: str, var_name: str, *, brace: str, closing: str) -> str:
    """
    Trouve la première affectation au symbole var_name et extrait le littéral
    délimité par brace/closing (compte les niveaux et ignore les chaînes).
    """
    # Cherche l'index du nom puis du '='
    m = re.search(rf"\b{re.escape(var_name)}\b", src)
    if not m:
        return ""
    i = m.end()
    # trouver le '=' après
    eq = src.find("=", i)
    if eq < 0:
        return ""
    # trouver la 1ère ouverture du littéral
    start = src.find(brace, eq)
    if start < 0:
        return ""

    # scanner avec un compteur d'accolades/crochets et gestion de chaînes
    depth = 0
    i = start
    in_str: str | None = None
    escape = False
    while i < len(src):
        ch = src[i]
        if in_str:
            if escape:
                escape = False
            elif ch == "\\":
                escape = True
            elif ch == in_str:
                in_str = None
        else:
            if ch in ("'", '"'):
                in_str = ch
            elif ch == brace:
                depth += 1
            elif ch == closing:
                depth -= 1
                if depth == 0:
                    end = i
                    return src[start : end + 1]
        i += 1
    return ""  # pas trouvé (illégal)


def _safe_eval_dict(literal: str) -> dict:
    if not literal:
        return {}
    # ast.literal_eval supporte les dicts/strings en quotes simples
    obj = ast.literal_eval(literal)
    if not isinstance(obj, dict):
        raise ValueError("Littéral ORIGIN_TREE n'est pas un objet.")
    return obj


def _safe_eval_any(literal: str):
    if not literal:
        return []
    return ast.literal_eval(literal)


def _normalize_books(raw: Any) -> List[str]:
    """
    Accepte : ['A', 'B'] ou [{'title':'A'}, ...] et normalise en liste de chaînes.
    """
    if raw is None:
        return []
    if isinstance(raw, list):
        out: List[str] = []
        for item in raw:
            if isinstance(item, dict):
                title = item.get("title")
                if title:
                    out.append(str(title))
            else:
                out.append(str(item))
        # unique + ordre stable
        seen = set()
        uniq: List[str] = []
        for b in out:
            if b not in seen:
                seen.add(b)
                uniq.append(b)
        return uniq
    # si c'est une chaîne seule
    return [str(raw)]
